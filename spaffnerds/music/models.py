# -*- coding: utf-8 -*-
"""User models."""
import datetime as dt

from spaffnerds.database import Column, Model, SurrogatePK, db, reference_col, relationship
from spaffnerds.extensions import bcrypt, admin
from sqlalchemy.ext.associationproxy import association_proxy
from sqlalchemy.ext.orderinglist import ordering_list
from sqlalchemy.orm.collections import attribute_mapped_collection
from sqlalchemy.sql import func, select
from sqlalchemy.ext.hybrid import hybrid_property
from sqlalchemy.orm import column_property
from sqlalchemy import and_

from flask_admin.contrib.sqla import ModelView

def get_count(q):
    count_q = q.statement.with_only_columns([func.count()]).order_by(None)
    count = q.session.execute(count_q).scalar()
    return count


class Show(SurrogatePK, Model):
    """show"""
    __tablename__ = 'shows'
    id = db.Column(db.Integer, primary_key=True)
    name = Column(db.String(200))
    date = Column(db.DateTime)
    notes = Column(db.Text)
    archive_id = Column(db.String(80))
    streamable = Column(db.Boolean)

    # _songs 
    songs = association_proxy('showsongs', 'song')

    venue_id = reference_col('venues', nullable=True)
    venue = relationship('Venue', backref='shows')

    def __init__(self, name, **kwargs):
        """Create instance."""
        db.Model.__init__(self, name=name, **kwargs)

    def __repr__(self):
        return '<Show %r>' % (self.date)

    def get_songs(self):
        """
        get songs
        """
        return self.songs

    def get_upcoming_shows(self):
        # return shows from the future for schedule
        pass

    def add_show(self, date, notes):
        # metafunction to add show
        pass


class Song(SurrogatePK, Model):
    """
        A song
    """

    __tablename__ = 'songs'
    id = db.Column(db.Integer, primary_key=True)
    name = Column(db.String(200))
    system_name = Column(db.String(200), unique=True)
    is_cover = Column(db.Boolean, default=False)
    original_artist = Column(db.String(250))
    notes = Column(db.Text)
    written_by = Column(db.String(200))
    # first played?
    # relationship for last date played and first date?

    # show_id = reference_col('shows', nullable=True)
    # show = relationship('Show', backref='show')

    shows = relationship(
        'Show',
        secondary='show_song_link'
    )
    show_date = association_proxy('shows', 'date')
    # @hybrid_property
    # def times_played(self):
    #     if self.shows:
    #         return len(self.shows)
    #     else:
    #         return 0

    def __init__(self, name, **kwargs):
        """Create instance."""
        if name:
            self.system_name = str(name).lower().replace(' ', '-')
        db.Model.__init__(self, name=name, **kwargs)

    def __repr__(self):
        return '<Song %r>' % (self.name)


class ShowSongLink(SurrogatePK, Model):
    """
        associations between Show and Song
        -track_order and show_set are required
    """

    __tablename__ = 'show_song_link'
    id = db.Column(db.Integer, primary_key=True)
    show_id = Column(
        db.Integer,
        db.ForeignKey('shows.id'),
        primary_key=True)
    song_id = Column(
        db.Integer,
        db.ForeignKey('songs.id'),
        primary_key=True)
    track_order = Column(db.Integer)  # 1,2,3,4,5
    song_notes = Column(db.Text)  # autogenerated character reference?
    show_set = Column(db.String(30))  # 1,2,3,E1,E2,E3 etc?
    segued = Column(db.Boolean, default=False)

    show = relationship(
        Show,
        backref='showsongs'  # ,
        # collection_class=attribute_mapped_collection("track_order"),
        # cascade="all, delete-orphan"
    )

    song = relationship('Song')
    song_sys_name = association_proxy('song', 'system_name')
    song_name = association_proxy('song', 'name')

    def __init__(self, track_order, show_set, **kwargs):
        """Create instance."""
        db.Model.__init__(self, track_order=track_order, show_set=show_set, **kwargs)

    def __repr__(self):
        return '<ShowSongLink %r-%r>' % (self.track_order, self.song_name)


class Venue(SurrogatePK, Model):
    """A venue of shows."""

    __tablename__ = 'venues'
    id = db.Column(db.Integer, primary_key=True)
    name = Column(db.String(200))
    email = Column(db.String(250))
    phone = Column(db.String(15))
    loc_address = Column(db.String(250))
    loc_city = Column(db.String(80))
    loc_state = Column(db.String(4))
    loc_zip = Column(db.String(80))
    latitude = Column(db.String(80))  # autogeocode
    longitude = Column(db.String(80))  # autogeocode
    notes = Column(db.Text)

    # date_last_played = column_property(
    #     select([func.max(Show.date)]).
    #     where(Show.venue_id == id).
    #     correlate_except(Show)
    # )
    # date_first_played = column_property(
    #     select([func.min(Show.date)]).
    #     where(Show.venue_id == id).
    #     correlate_except(Show)
    # )

    # @hybrid_property
    # def times_played(self):
    #     if self.shows:
    #         return len(self.shows)
    #     else:
    #         return 0

    # @hybrid_property
    # def city_state(self):
    #     if self.loc_city and self.loc_state:
    #         return '{0}, {1}'.format(self.loc_city, self.loc_state)

    def __init__(self, name, **kwargs):
        """Create instance."""
        db.Model.__init__(self, name=name, **kwargs)

    def __repr__(self):
        return '<Venue %r>' % (self.name)

    def get_shows_per_venue(self):
        return self.shows

    def get_times_played(self):
        """
        get # of shows played at this venue
        """
        return len(self.shows)

    def get_date_last_played(self):
        """
        get date of last show played here
        """
        date_max = self.shows.filter(func.max(Show.date))
        return date_max


# Song.date_last_played = column_property(
#     select([func.max(Show.date)]).
#     where(ShowSongLink.song_id == Song.id).
#     correlate_except(Show)
# )
# Song.date_first_played = column_property(
#     select([func.min(Show.date)]).
#     where(ShowSongLink.song_id == Song.id).
#     correlate_except(Show)
# )

admin.add_view(ModelView(Show, db.session))
admin.add_view(ModelView(Song, db.session))
admin.add_view(ModelView(Venue, db.session))
admin.add_view(ModelView(ShowSongLink, db.session))


# Universal functions
def add_song():
    """
        add or update song
    """
    pass


def add_venue():
    """ 
        add or update venue
    """
    pass


def add_show(show, songs, venue):
    """
        add or update show
    """
    venue = Venue(**venue)
    show = Show(**show)

    for s in songs:

        show.song_assoc.append(
            ShowSongLink(
                track_order=s['track_order'],
                show_set=s['show_set'],
                song_=Song(
                    song_id=s['song_id']
                    ),
                **s
            ))


def session_commit():
    try:
        db.session.commit()
    except SQLAlchemyError as e:
        db.session.rollback()
        reason = str(e)
        return reason
